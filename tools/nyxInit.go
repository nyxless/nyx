package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path"
	"path/filepath"
	"strings"
	"unicode"
)

var appname string

func main() {

	currentDir, err := os.Getwd()
	if err != nil {
		fmt.Println("获取当前工作目录失败:", err)
		return
	}

	flag.StringVar(&appname, "name", path.Base(currentDir), "application name")
	flag.Parse()

	// 指定要解析的文件路径
	apiDir := currentDir + "/controller/api/"
	rpcDir := currentDir + "/controller/rpc/"
	cliDir := currentDir + "/controller/cli/"

	apis, err := parseDir(apiDir, "", map[string]map[string][]string{})
	if err != nil {
		fmt.Println("获取api列表时出错:", err)
	}

	rpcs, err := parseDir(rpcDir, "", map[string]map[string][]string{})
	if err != nil {
		fmt.Println("获取rpc列表时出错:", err)
	}

	clis, err := parseDir(cliDir, "", map[string]map[string][]string{})
	if err != nil {
		fmt.Println("获取cli列表时出错:", err)
	}

	writeAutoload(apis, rpcs, clis)
}

func parseDir(dir, group string, structs map[string]map[string][]string) (map[string]map[string][]string, error) { // {{{
	files, err := os.ReadDir(dir)
	if err != nil {
		return nil, err
	}

	dir = strings.TrimRight(dir, "/")
	group = strings.Trim(group, "/")

	for _, file := range files {
		if file.IsDir() {
			_group := group + "/" + file.Name()
			structs, err = parseDir(filepath.Join(dir, file.Name()), _group, structs)
			continue
		}

		_structs, err := parseFile(filepath.Join(dir, file.Name()))
		if err != nil {
			fmt.Println(err)
		} else {
			//structs[group] = append(structs[group], structName)
			if structs[group] == nil {
				structs[group] = map[string][]string{}
			}

			for k, v := range _structs {
				structs[group][k] = v
			}
		}
	}

	return structs, nil
} // }}}

func parseFile(fpath string) (map[string][]string, error) { // {{{

	if !strings.HasSuffix(fpath, ".go") {
		return nil, fmt.Errorf("[\033[1;31;33m%s\033[0m] is not gofile, ignored", fpath)
	}

	// 创建一个新的文件集
	fset := token.NewFileSet()

	//--------fmt.Println(fpath)
	// 解析文件
	node, err := parser.ParseFile(fset, fpath, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("解析文件失败：%v\n", err)
	}

	// 用于存储 struct 和其方法的 map
	structMethods := make(map[string][]string)

	// 遍历 AST 节点
	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		/*
			case *ast.TypeSpec:
				if _, ok := x.Type.(*ast.StructType); ok {
					// 获取 struct 名称
					structName := x.Name.Name
					// 初始化方法列表
					structMethods[structName] = []string{}
				}
		*/
		case *ast.FuncDecl:
			if x.Recv != nil {
				// 获取方法的接收者类型
				for _, field := range x.Recv.List {
					var structName string
					switch t := field.Type.(type) {
					case *ast.Ident:
						// 如果是直接类型，直接获取名称
						structName = t.Name
					case *ast.StarExpr:
						// 如果是指针类型，获取指针指向的类型名称
						if ident, ok := t.X.(*ast.Ident); ok {
							structName = ident.Name
						}
					}
					if structName != "" && unicode.IsUpper(rune(structName[0])) && strings.HasSuffix(structName, "Controller") && strings.HasSuffix(x.Name.Name, "Action") {
						// 添加方法名称到 struct 的方法列表
						structMethods[structName] = append(structMethods[structName], x.Name.Name)
					}
				}
			}
		}
		return true
	})

	return structMethods, nil

	/*
		// 遍历文件中的所有声明
		for _, decl := range file.Decls {

			// 检查是否是类型声明
			genDecl, ok := decl.(*ast.GenDecl)
			if ok && genDecl.Tok == token.TYPE {
				// 遍历类型声明中的每个类型
				for _, spec := range genDecl.Specs {
					typeSpec := spec.(*ast.TypeSpec)
					// 检查是否是 struct 类型
					if _, ok := typeSpec.Type.(*ast.StructType); ok {
						structName := typeSpec.Name.Name
						if unicode.IsUpper(rune(structName[0])) && strings.HasSuffix(structName, "Controller") {
							return structName, nil
						}
					}
				}
			}
		}
		return nil, nil
	*/
} // }}}

func writeAutoload(apis, rpcs, clis map[string]map[string][]string) { // {{{
	if len(apis) == 0 && len(rpcs) == 0 && len(clis) == 0 {
		return
	}

	err := os.Mkdir("autoload", 0750)
	if err != nil && !os.IsExist(err) {
		panic(err)
	}

	f, err := os.Create("autoload/registerMethod.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	str := `// Code generated by nyx-init. DO NOT EDIT.

package autoload 

import "github.com/nyxless/nyx/x"
import "net/http"
import "context"
`
	for group, _ := range apis {
		if group != "" {
			str += `import "` + appname + `/controller/api/` + group + `"
`
		} else {
			str += `import "` + appname + `/controller/api"
`
		}
	}

	for group, _ := range rpcs {
		if group != "" {
			str += `import "` + appname + `/controller/rpc/` + group + `"
`
		} else {
			str += `import "` + appname + `/controller/rpc"
`
		}
	}

	for group, _ := range clis {
		if group != "" {
			str += `import "` + appname + `/controller/cli/` + group + `"
`
		} else {
			str += `import "` + appname + `/controller/cli"
`
		}
	}

	str += `
func init() {
`
	route_str := ""
	route_func_str := ""
	for group, names := range apis {
		for k, v := range names {
			cname := strings.TrimSuffix(k, "Controller")
			pkg := "api"

			if group != "" {
				cname = group + "/" + cname
				pkg = path.Base(group)
				str += "\tx.AddApi(&" + pkg + "." + k + "{}, \"" + group + "\")\n"
			} else {
				str += "\tx.AddApi(&api." + k + "{})\n"
			}

			cname = strings.ToLower(cname)
			for _, m := range v {
				aname := strings.ToLower(strings.TrimSuffix(m, "Action"))
				route_str += "\tx.AddRouteApiFunc(\"" + cname + "\", \"" + aname + "\", route_api_" + strings.ReplaceAll(cname, "/", "_") + "_" + aname + ")\n"

				route_func_str += "func route_api_" + strings.ToLower(strings.ReplaceAll(cname, "/", "_")) + "_" + strings.ToLower(aname) + "(w http.ResponseWriter, r *http.Request) {\n"
				route_func_str += "\t\tc := &" + pkg + "." + k + "{}\n"
				route_func_str += "\t\tdefer func() {\n"
				route_func_str += "\t\t\tif err := recover(); err != nil {\n"
				route_func_str += "\t\t\t\tc.RenderError(err)\n"
				route_func_str += "\t\t\t}\n"
				route_func_str += "\t\t}()\n\n"
				route_func_str += "\t\tc.Prepare(w, r, \"" + cname + "\", \"" + aname + "\")\n"
				route_func_str += "\t\tc.Init()\n"
				route_func_str += "\t\tc." + m + "()\n"
				route_func_str += "}\n\n"
			}

		}
	}

	for group, names := range rpcs {
		for k, v := range names {
			cname := strings.TrimSuffix(k, "Controller")
			pkg := "rpc"

			if group != "" {
				cname = group + "/" + cname
				pkg = path.Base(group)
				str += "\tx.AddRpc(&" + pkg + "." + k + "{}, \"" + group + "\")\n"
			} else {
				str += "\tx.AddRpc(&rpc." + k + "{})\n"
			}

			cname = strings.ToLower(cname)
			for _, m := range v {
				aname := strings.ToLower(strings.TrimSuffix(m, "Action"))
				route_str += "\tx.AddRouteRpcFunc(\"" + cname + "\", \"" + aname + "\", route_rpc_" + strings.ReplaceAll(cname, "/", "_") + "_" + aname + ")\n"

				route_func_str += "func route_rpc_" + strings.ToLower(strings.ReplaceAll(cname, "/", "_")) + "_" + strings.ToLower(aname) + "(params map[string]any, ctx context.Context) (res map[string]any) {\n"
				route_func_str += "\t\tc := &" + pkg + "." + k + "{}\n"
				route_func_str += "\t\tdefer func() {\n"
				route_func_str += "\t\t\tif err := recover(); err != nil {\n"
				route_func_str += "\t\t\t\tc.RenderError(err)\n"
				route_func_str += "\t\t\t\tres = c.GetRpcContent()\n"
				route_func_str += "\t\t\t}\n"
				route_func_str += "\t\t}()\n\n"
				route_func_str += "\t\tc.PrepareRpc(params, ctx, \"" + cname + "\", \"" + aname + "\")\n"
				route_func_str += "\t\tc.Init()\n"
				route_func_str += "\t\tc." + m + "()\n"
				route_func_str += "\t\tres = c.GetRpcContent()\n"
				route_func_str += "\t\treturn\n"
				route_func_str += "}\n\n"
			}
		}
	}

	for group, names := range clis {
		for k, _ := range names {
			if group != "" {
				pkg := path.Base(group)
				str += "\tx.AddCli(&" + pkg + "." + k + "{}, \"" + group + "\")\n"
			} else {
				str += "\tx.AddCli(&cli." + k + "{})\n"
			}
		}
	}

	str += "\n" + route_str + "\n}\n\n"

	str += route_func_str

	_, err = f.WriteString(str)

	if err != nil {
		panic(err)
	}

	fmt.Println("\033[32m 成功生成文件 autoload/registerMethod.go!\033[0m")

} // }}}

//
//
